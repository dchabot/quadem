<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>synApps quadEM</title>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type" />
</head>
<body>
  <div style="text-align: center">
    <h1>
      quadEM Driver</h1>
    <h2>
      Mark Rivers, University of Chicago</h2>
  </div>
  <h2>
    Contents</h2>
  <ul>
    <li><a href="#Overview">Overview</a></li>
    <li><a href="#Databases">Databases</a>
      <ul>
        <li><a href="#quadEM">quadEM.template</a></li>
        <li><a href="#quadEM_TimeSeries">quadEM_TimeSeries.template</a></li>
        <li><a href="#fast_pid_control">fast_pid_control.db</a></li>
      </ul>
    </li>
    <li><a href="#Performance">Performance</a></li>
    <li><a href="#AHxxx_Setup">AH401 and AH501 series Setup</a></li>
    <li><a href="#APS_EM_Setup">APS Electrometer Setup</a></li>
  </ul>
  <h2 id="Overview">
    Overview</h2>
  <p>
    <b>quadEM</b> supports quad electrometers/picoammeters, typically used for photodiode-based
    x-ray beam position monitors, or split ion chambers. They can also be used for any
    low-current measurement that requires high speed digital input. There is support
    for several models:</p>
  <ol>
    <li>The AH401 series (AH401B, AH401D) and AH501 series (AH501, AH501C, AH501D) picoammeters
      designed and sold by <a href="http://ilo.elettra.trieste.it/index.php?page=_layout_prodotto&amp;id=54&amp;lang=en">
        Synchrotron Trieste (elettra)</a>. They are also sold by <a href="http://www.caenels.com/caenels/product.php?fam=cemis&amp;mod=AH401B">
          CAENels</a>. These devices communicate using TCP or UDP over 100 Mbit/s Ethernet
      or high-speed serial. They provide 4-channel current measurements at up to 6510
      Hz (AH501 series) or 1000 Hz (AH401 series).</li>
    <li>The Quad Electrometer built by <a href="mailto:skross@aps.anl.gov">Steve Ross</a>
      from the APS (called APS_EM in this document). This device consists of a 4-channel
      digital electrometer unit and 2 VME boards. The device provides 2 readings per diode
      at up to 813 Hz.</li>
  </ol>
  <p>
    The AH401 series and the APS_EM are based on the same principle of an op-amp run
    as a current amplifier with a large feedback capacitor, and a high resolution ADC.
    The AH501 series are based on a transimpedance input stage for current sensing,
    combined with analog signal conditioning and filtering stages. The AH501C and AH501D
    have an integrated programmable bias supply.</p>
  <p>
    The <b>quadEM</b> software includes asyn drivers and an SNL program that provide
    support for the following:</p>
  <ul>
    <li>Analog input records using the standard asynInt32Average device support. This
      provides digitally averaged readings of the current, sum, difference and position
      at speeds up to 10 Hz with standard EPICS scan times. One could also use the standard
      asynInt32 device support with ai records and scan=I/O Intr, in which case the record
      would update with every reading from the device. This is likely to overwhelm the
      EPICS IOC if the electrometer is run at very fast sampling times.</li>
    <li>Time series data (like a digital scope) of the current, sum, difference and position
      at speeds up to 6510 Hz (AH501 series), 1000 Hz (AH401 series) or 813 Hz (APS_EM).
      The data is available in standard EPICS waveform records, using the drvFastSweep
      asyn driver from the synApps "mca" module. The time per point can be greater, in
      which case it does averaging.</li>
    <li>FFTs of the time series data, providing the power spectrum of each signal as another
      EPICS waveform record.</li>
    <li>epid (fast feedback). This provides fast feedback via an asyn D/A converter (e.g.
      dac128V), also at speeds up to 6510 Hz, 1000Hz or 813Hz. If it is run slower it
      does signal averaging. This support is provided in the synApps "std" module. The
      quadEM drivers do the callbacks on the asynFloat64 interface required to use the
      epics fast feedback device support.</li>
  </ul>
  <p>
    The following manuals provide detailed information on these devices:</p>
  <ul>
    <li>APS electrometer: <a href="Electrometer_Users_Guide_01_22_2007.pdf">Electrometer
      Users Guide</a></li>
    <li>AH401B electrometer: <a href="AH401B_UsersManual_V1.0.pdf">AH401B Users Manual</a></li>
    <li>AH401D electrometer: <a href="AH401D_UsersManual_V1.2.pdf">AH401D Users Manual</a></li>
    <li>AH501C electrometer: <a href="AH501C_UsersManual_V1.0.pdf">AH501C Users Manual</a></li>
    <li>AH501D electrometer: <a href="AH501D_UsersManual_V1.0.pdf">AH501D Users Manual</a></li>
  </ul>
  <p>
    The support is based on asynPortDriver. It consists of a base class <a href="quadEMDoxygenHTML/classdrv_quad_e_m.html">
      (drvQuadEM.cpp)</a> which is device-independent. There are device-dependent classes
    for the AH401 and AH501 series <a href="quadEMDoxygenHTML/classdrv_a_hxxx.html">(drvAHxxx.cpp)</a>
    and the APS electrometer <a href="quadEMDoxygenHTML/classdrv_a_p_s___e_m.html">(drvAPS_EM.cpp)</a>.
    There is an EPICS State Notation Language (SNL) program (quadEM_SNL.st) is used
    to synchronize acquisition of time-series data, and to compute FFT power-spectra
    of the time-series data.</p>
  <h2 id="Databases">
    Databases</h2>
  <h3 id="quadEM">
    quadEM.template</h3>
  <p>
    The quadEM.template database provides control of the electrometer and analog input
    records using the standard asyn device support. This provides digitally averaged
    readings of the current, sum, difference and position at speeds up to 10 Hz with
    standard EPICS scan times. For the data values the analog input records use asynInt32Average
    device support, which averages all callback readings between record processing.
    The driver also does callbacks for these same values on the asynFloat64 interface,
    which is required by the fast feedback device support for the EPID record. It also
    does asynInt32Array callbacks with an array for each of the 11 values (Current1
    to Position34), which is required by the drvFastSweep driver for time-series data.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="7">
          <b>Records in quadEM.template</b></td>
      </tr>
      <tr>
        <th>
          drvInfo string</th>
        <th>
          EPICS record name</th>
        <th>
          EPICS record type</th>
        <th>
          asyn interface</th>
        <th>
          Access</th>
        <th>
          Models supported</th>
        <th>
          Description</th>
      </tr>
      <tr>
        <td>
          QE_MODEL</td>
        <td>
          $(P)$(R)Model</td>
        <td>
          mbbi</td>
        <td>
          asyInt32</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          The model of the electrometer. This is determined automatically by the driver. Values
          are:
          <ul>
            <li>0: Unknown</li>
            <li>1: APS_EM</li>
            <li>2: AH401B</li>
            <li>3: AH401D</li>
            <li>4: AH501</li>
            <li>5: AH501C</li>
            <li>6: AH501D</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_ACQUIRE</td>
        <td>
          $(P)$(R)Acquire</td>
        <td>
          bo</td>
        <td>
          asyInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Acquire command. This command turns acquisition on (1) and off (0).</td>
      </tr>
      <tr>
        <td>
          QE_RANGE</td>
        <td>
          $(P)$(R)Range</td>
        <td>
          mbbo</td>
        <td>
          asyInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Range command. This selects the sensitivity of the electrometer (A/D units per nanoamp).<br />
          For the AH501 series the choices are:
          <ul>
            <li>&plusmn;2.5mA</li>
            <li>&plusmn;2.5uA</li>
            <li>&plusmn;2.5nA</li>
          </ul>
          For the AH401 series this selects the feedback capacitor, which controls the gain
          of the device. There are 8 capacitor choices in units of saturation charge:
          <ul>
            <li>1800 pC</li>
            <li>350 pC</li>
            <li>300 pC</li>
            <li>250 pC</li>
            <li>200 pC</li>
            <li>150 pC</li>
            <li>100 pC</li>
            <li>50 pC</li>
          </ul>
          For the APS_EM this selects the feedback capacitor, which controls the gain of the
          device. There are 8 capacitor choices:
          <ul>
            <li>External</li>
            <li>17.6 pf</li>
            <li>8.80 pF</li>
            <li>5.87 pF</li>
            <li>4.40 pF</li>
            <li>3.52 pF</li>
            <li>2.93 pF</li>
            <li>2.51 pF</li>
          </ul>
          On the APS_EM all gains except the first External gain use capacitors that are built
          in to the Burr Brown chip. These are quite small capacitors and only cover a narrow
          range, so the gains are quite high, and only rather low currents can be measured
          with them, even at the shortest integration times. The external capacitors can be
          replaced to select the first gain, and boards are normally built with 220 pF external
          capacitors. At APS 13-ID we have used much larger values, 1000 to 5000 pF, because
          the currents from our undulator beam position monitor are large. There are actually
          8 external capacitors: 4 of them control the gain for each input for the "ping"
          channel, and the other 4 control the gain for the "pong" channel. By using one capacitor
          value for the 4 diodes on the ping channel and a different capacitor value for the
          4 diodes on the pong channel, then two user-selectable gains are available. One
          must then select the appropriate channel in the PingPong record, and not use the
          average.</td>
      </tr>
      <tr>
        <td>
          QE_PING_PONG</td>
        <td>
          $(P)$(R)PingPong</td>
        <td>
          mbbo</td>
        <td>
          asyInt32</td>
        <td>
          r/w</td>
        <td>
          AH401 series, APS_EM</td>
        <td>
          Both the AH401 series and the APS_EM have 2 input channels, which we call Ping and
          Pong here. This doubles the speed of the unit, because one channel is being digitized
          while the other is integrating. This record selects how the two channels are treated.<br />
          On the AH401 series the choices are "Off" (0) and "On" (1). "Off" only returns the
          data from the Ping channel. This reduces noise because only a single integration
          capacitor is used, but it reduces the data rate by a factor of two, because data
          are only returned on every other integration time. "On" returns the data from both
          channels, which doubles the data rate at some expense in noise.<br />
          On the APS_EM both values are always transmitted from the device, and the choices
          are #1 (Ping), #2 (Pong), and Avg. which averages the values from the Ping and Pong
          channels. Note that if Range=External and the two external capacitors are different,
          then one should not use Avg. because that will mix data from two different gains.
        </td>
      </tr>
      <tr>
        <td>
          QE_INTEGRATION_TIME</td>
        <td>
          $(P)$(R)IntegrationTime</td>
        <td>
          ao</td>
        <td>
          asynFloat64</td>
        <td>
          r/w</td>
        <td>
          AH401 series, APS_EM</td>
        <td>
          Selects the integration time of the amplifier. As the integration time is increased
          the sensitivity increases, but the number of readings/sec sent from the device is
          decreased.<br />
          For the AH401 series values range from 0.001s to 1.000s. The data are sent after
          one integration time if PingPong="On" or after 2 integration times if PingPong="Off".<br />
          For the APS_EM the values range from .000615s to 0.1311s. The data are sent to the
          VME card from the amplifier after 2 integration times, one value in the Ping channel
          and one value in the Pong channel. The data period is thus 0.00123 to 0.02622 s,
          or a frequency range of about 813 Hz to 38.1 Hz. </td>
      </tr>
      <tr>
        <td>
          QE_NUM_CHANNELS</td>
        <td>
          $(P)$(R)NumChannels</td>
        <td>
          mbbo</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          AH501 series</td>
        <td>
          Selects the number of channels to measure and transmit data for. Using fewer than
          4 channels increases the sampling rate. Allowed choices are:
          <ul>
            <li>1: channel 1 only</li>
            <li>2: channels 1 and 2 only</li>
            <li>4: channels 1-4</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_RESOLUTION</td>
        <td>
          $(P)$(R)Resolution</td>
        <td>
          mbbo</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          AH501 series</td>
        <td>
          Selects the resolution of the ADC in bits. Using 16-bits increases the sampling
          rate by a factor of 2 relative to 26-bits. Allowed choices are:
          <ul>
            <li>16: 16-bit data</li>
            <li>24: 24-bit data</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_BIAS_STATE</td>
        <td>
          $(P)$(R)BiasState</td>
        <td>
          bo</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          AH501C and AH501D</td>
        <td>
          Selects the state of the bias supply output voltage. Allowed choices are:
          <ul>
            <li>0: Off</li>
            <li>1: On</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_BIAS_VOLTAGE</td>
        <td>
          $(P)$(R)BiasVoltage</td>
        <td>
          ao</td>
        <td>
          asynFloat64</td>
        <td>
          r/w</td>
        <td>
          AH501C and AH501D</td>
        <td>
          Controls the voltage of the bias supply output. </td>
      </tr>
      <tr>
        <td>
          QE_NUM_AVERAGE</td>
        <td>
          $(P)$(R)NumAverage</td>
        <td>
          longout</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Controls the number of readings from the meter that are averaged in the driver before
          it does callbacks. The default is 1 (no averaging). Setting NumAverage &gt; 1 will
          reduce the CPU time for 2 reasons:
          <ol>
            <li>On the AH401 and AH501 series the driver reduces the frequency of asynOctet-&gt;read()
              calls by a factor of NumAverage, because it can obtain multiple readings from the
              meter in a single call. This is particularly significant on the AH501 series, which
              can transmit up to 26,040 packets per second!</li>
            <li>It reduces the frequency of callbacks to device support.</li>
          </ol>
          The potential disadvantage of setting NumAverage &gt; 1 is that it will reduce the
          sampling frequency of the TimeSeries support, and the update frequency of the EPID
          fast feedback support. </td>
      </tr>
      <tr>
        <td>
          QE_SAMPLE_TIME</td>
        <td>
          $(P)$(R)SampleTime_RBV</td>
        <td>
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Provides the actual time between sample readings from the device. This is controlled
          by the following parameters:
          <ul>
            <li>NumAverage: All models</li>
            <li>IntegrationTime: AH401 series and APS_EM</li>
            <li>PingPong: AH401 series</li>
            <li>NumChannels: AH501 series</li>
            <li>Resolution: AH501 series</li>
          </ul>
          The sample time on the AH501 series is controlled by the following algorithm:
          <ul>
            <li>SampleTime = 38.4 microseconds * NumChannels * NumAverage</li>
            <li>If Resolution == 24 then SampleTime = SampleTime * 2</li>
          </ul>
          The minimum sample time (NumChannels=1, NumAverage=1, Resolution=16) is 38.4 microseconds,
          or a sampling frequency of 26.04 kHz. The maximum sample time with NumAverage=1,
          NumChannels=4, Resolution=24 is 307.2 microseconds, or a sampling frequency of 3.255
          kHz. Setting NumAverage &gt; 1 will increase the sample time and reduce the sampling
          frequency proportionally.<br />
          <br />
          The sample time on the AH401 series is controlled by the following algorithm:
          <ul>
            <li>SampleTime = IntegrationTime * NumAverage</li>
            <li>If PingPong == 0 then SampleTime = SampleTime * 2</li>
          </ul>
          The minimum sample time is 0.001 seconds, or 1 kHz sampling frequency. The maximum
          sampling time (PingPong=0) is 2 seconds, or 0.5 Hz sampling frequency. Setting NumAverage
          &gt; 1 will increase the sample time and reduce the sampling frequency proportionally.<br />
          <br />
          For the APS_EM the sample time is controlled only by NumAverage and the IntegrationTime,
          which ranges from 0.00123 to 0.02622 s, or a sampling frequency range of about 813
          Hz to 38.1 Hz. </td>
      </tr>
      <tr>
        <td>
          QE_TRIGGER</td>
        <td>
          $(P)$(R)Trigger</td>
        <td>
          bo</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          AH501 and AH401 series</td>
        <td>
          Controls whether acquisition is free-running ("No") or triggered by an external
          pulse ("Yes").</td>
      </tr>
      <tr>
        <td>
          QE_RESET</td>
        <td>
          $(P)$(R)Reset</td>
        <td>
          bo</td>
        <td>
          asyInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Reset command. Processing this record will reset the electrometer. On the APS_EM
          this operation takes about 1 second, and may be required to establish communication
          if the amplifier unit is power-cycled or disconnected and reconnected. On the AH401
          and AH501 series this operation downloads all of the EPICS settings to the electrometer,
          and must be done if the electrometer is power-cycled without rebooting the EPICS
          IOC.</td>
      </tr>
      <tr>
        <td>
          QE_CURRENT_OFFSET</td>
        <td>
          $(P)$(R)CurrentOffset[1-4]</td>
        <td>
          ao</td>
        <td>
          asynInt32 (addr=0-3)</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Offset that will be subtracted from each reading before calculating the Current[1-4].
        </td>
      </tr>
      <tr>
        <td>
          QE_POSITION_OFFSET</td>
        <td>
          $(P)$(R)PositionOffset[12,34]</td>
        <td>
          ao</td>
        <td>
          asynInt32 (addr=0-1)</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Offset that will be subtracted from the computed position.</td>
      </tr>
      <tr>
        <td>
          QE_POSITION_SCALE</td>
        <td>
          $(P)$(R)PositionScale[12,34]</td>
        <td>
          ao</td>
        <td>
          asynInt32 (addr=0-1)</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Scale factor used when computing the position.</td>
      </tr>
      <tr>
        <td>
          QE_DATA</td>
        <td>
          $(P)$(R)Current[1-4]</td>
        <td>
          ai</td>
        <td>
          asynInt32 (addr=0-3)</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          The value of the current. This is calculated as measuredValue-CurrentOffset. These
          records use asynInt32Average device support so they average the readings from the
          device since the time the record was last processed. For example with the AH401
          series if PingPong="On" and the integration time is 0.002s (500 Hz), if the Read
          record .SCAN field is 1 second then 500 readings will be averaged.</td>
      </tr>
      <tr>
        <td>
          QE_DATA</td>
        <td>
          $(P)$(R)Sum[12,34,1234]</td>
        <td>
          ai</td>
        <td>
          asynInt32 (addr=4-6)</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          The sum of diodes 1+2, 3+4, and 1+2+3+4. These records use asynInt32Average device
          support so they average the readings from the device since the time the record was
          last processed.</td>
      </tr>
      <tr>
        <td>
          QE_DATA</td>
        <td>
          $(P)$(R)Diff[12,34]</td>
        <td>
          ai</td>
        <td>
          asynInt32 (addr=7-8)</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          The difference of the diode pair 2-1 and 4-3. These records use asynInt32Average
          device support so they average the readings from the device since the time the record
          was last processed.</td>
      </tr>
      <tr>
        <td>
          QE_DATA</td>
        <td>
          $(P)$(R)Position[12,34]</td>
        <td>
          ai</td>
        <td>
          asynInt32 (addr=9-10)</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          The position of the diode pair. This is calculated as ((Diff/Sum)*PositionScale
          - PositionOffset). These records use asynInt32Average device support so they average
          the readings from the device since the time the record was last processed.</td>
      </tr>
      <tr>
        <td>
          QE_DOUBLE_DATA</td>
        <td>
          N.A.</td>
        <td>
          N.A.</td>
        <td>
          asynFloat64 (addr=0-10)</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          The QE_DOUBLE_DATA drvInfo string is used to read the same information as QE_DATA,
          but using the asynFloat64 interface rather than the asynInt32 interface. This is
          provided to support the fast feedback device support for the EPID record, which
          is provided in the synApps "std" module. That device support expects callbacks on
          the asynFloat64 interface for its input data.</td>
      </tr>
      <tr>
        <td>
          N.A.</td>
        <td>
          $(P)$(R)Read</td>
        <td>
          ai</td>
        <td>
          N.A.</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Processing this record reads all of the Position, Sum, Diff, and Position records
          using forward links.</td>
      </tr>
    </tbody>
  </table>
  <p>
    This is the medm screen to control the quadEM with the records in quadEM.template.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      quadEM.adl</h3>
    <img alt="quadEM.png" src="quadEM.png" /></div>
  <h3 id="quadEM_TimeSeries">
    quadEM_TimeSeries.template</h3>
  <p>
    The quadEM_TimeSeries.template database provides a time-history (like a digital
    scope) of the current, sum, difference and position at speeds up to 6510 Hz (AH501
    series), 1000Hz (AH401 series) or 813 Hz (APS_EM). The time per point can be greater
    than the sampling time, in which case it does averaging. It also optionally uses
    FFTs to compute the frequency power-spectrum of each signal. The time-series support
    requires the drvFastSweep driver from the synApps mca module, and also the quadEM_SNL
    SNL program in this quadEM module. The time-series and frequency spectra are contained
    in standard EPICS waveform records.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="3">
          <b>Records in quadEM_TimeSeries.template</b></td>
      </tr>
      <tr>
        <th>
          EPICS record name</th>
        <th>
          EPICS record type</th>
        <th>
          Description</th>
      </tr>
      <tr>
        <td>
          $(P)$(R)SNL_Connected</td>
        <td>
          bi</td>
        <td>
          Indicates whether the SNL program has successfully connected to all required records
          in quadEM_TimeSeries.template.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)EraseAll</td>
        <td>
          bo</td>
        <td>
          Erases all time-series waveform records.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)EraseStart</td>
        <td>
          bo</td>
        <td>
          Erases and starts time series data acquisition.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)StartAll</td>
        <td>
          bo</td>
        <td>
          Starts all the MCA records without erasing them first.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)StopAll</td>
        <td>
          bo</td>
        <td>
          Stops time-series data acquisition.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Acquiring</td>
        <td>
          bo</td>
        <td>
          Stops time-series data acquisition.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)MaxChannels</td>
        <td>
          longin</td>
        <td>
          The maximum number of time-series points that can be acquired. Controlled by the
          value specified when the quadEM_TimeSeries.template file and quadEM_SNL SNL program
          were loaded.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)NuseAll</td>
        <td>
          longout</td>
        <td>
          Controls the number of time-series points to acquire before acquisition stops automatically.
        </td>
      </tr>
      <tr>
        <td>
          $(P)$(R)CurrentChannel</td>
        <td>
          longin</td>
        <td>
          The current time-series data point being acquired.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)ReadAll</td>
        <td>
          bo</td>
        <td>
          Forces all the time-series waveform records to process and read the current time-series
          data. This record can be periodically processed to read the time=series data as
          it is being acquired. Even if this record is Passive the time-series data will be
          read once when time-series data acquisition is complete.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Dwell</td>
        <td>
          ao</td>
        <td>
          The dwell time per point. This time is constrained to be an integer multiple of
          the SampleTime, whose range is discussed above. The readback value of $(P)$(R)Dwell_RBV
          gives the actual dwell time per point.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Dwell_RBV</td>
        <td>
          ai</td>
        <td>
          The actual dwell time per point, which may differ from Dwell, because the time per
          point is constrained to be a multiple of the sampling time.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)ElapsedReal</td>
        <td>
          ao</td>
        <td>
          The elapsed real time since time-series data acquisition started.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)PresetReal</td>
        <td>
          dfanout</td>
        <td>
          The preset real time. Time-series acquisition will stop if this value is reached.
          If this value is 0 then there is no preset real time.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)AutoRestartTS</td>
        <td>
          bo</td>
        <td>
          Controls whether time-series data acquisition is automatically restarted as soon
          as it completes. Choices are "No" and "Yes". This can be useful for producing a
          continuously updating display of frequency power-spectra, for example.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Current[1-4]TS</td>
        <td>
          waveform</td>
        <td>
          The time-series values for the diode currents.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Sum[12,34,1234]TS</td>
        <td>
          waveform</td>
        <td>
          The time-series values for the diode sums.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Diff[12,34]TS</td>
        <td>
          waveform</td>
        <td>
          The time-series values for the diode sums.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Position[12,34]TS</td>
        <td>
          waveform</td>
        <td>
          The time-series values for the diode positions.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)TimeAxis</td>
        <td>
          waveform</td>
        <td>
          An array of the times for the x-axis of time series plots.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)ComputeFFT</td>
        <td>
          bo</td>
        <td>
          Controls whether FFTs power-spectra are computed when time-series data acquisition
          completes. Choices are "No" and "Yes". The FFT calculations are done in the SNL
          program using the Numerical Recipes "four1" function.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Current[1-4]FFT</td>
        <td>
          waveform</td>
        <td>
          The frequency power-spectra for the diode currents.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Sum[12,34,1234]FFT</td>
        <td>
          waveform</td>
        <td>
          The frequency power-spectra for the diode sums.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Diff[12,34]FFT</td>
        <td>
          waveform</td>
        <td>
          The frequency power-spectra for the diode sums.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)Position[12,34]FFT</td>
        <td>
          waveform</td>
        <td>
          The frequency power-spectra for the diode positions.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)FreqAxis</td>
        <td>
          waveform</td>
        <td>
          An array of the frequencies for the x-axis of frequency power-spectrum plots.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)EnableClientWait</td>
        <td>
          bo</td>
        <td>
          A flag to control whether time-series data acquisition waits for a client to reset
          the ClientWait record.</td>
      </tr>
      <tr>
        <td>
          $(P)$(R)ClientWait</td>
        <td>
          busy</td>
        <td>
          A busy record which a client must set back to 0 to enable time-series data acquisition
          to continue if EnableClientWait is "Enable".</td>
      </tr>
    </tbody>
  </table>
  <p>
    This is the medm screen to control the records in quadEM_TimeSeries.template.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      quadEM_TimeSeries.adl</h3>
    <img alt="quadEM_TimeSeries.png" src="quadEM_TimeSeries.png" /></div>
  <p>
    This is the medm screen for the first 2 channels. It contains the currents, sum
    and position as a function of time. The dwell time was 0.002s, and there are 2048
    channels (time points), so the total time is 4.096 seconds.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      quadEM_PlotAll.adl</h3>
    <img alt="quadEM_TimeSeriesPlot.png" src="quadEM_TimeSeriesPlot.png" /></div>
  <p>
    This is an medm screen that displays the FFTs of the Current, Sum, and Position
    for the time-series data above.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      quadEM_plotAll.adl</h3>
    <img alt="quadEM_FFTPlot.png" src="quadEM_FFTPlot.png" /></div>
  <h3 id="fast_pid_control">
    fast_pid_control.db
  </h3>
  <p>
    The quadEM can be used to do fast feedback with the EPID record from the synApps
    "std" module. The EPID record will process at up to the SampleTime discussed above.
    The DT field of the EPID record controls the time between feedback calculations,
    and this is constrained to be an integer multiple N of the quadEM SampleTime. If
    N>1 then N samples are averaged for each feedback operation.
  </p>
  <p>
    This is the medm screen that controls the fast feedback of the pitch of the monochromator
    on APS beamline 13-ID. The readback and control PVs cannot be changed after iocInit.
    The update rate (SCAN rate of EPID record) only controls the rate at which the EPID
    record displays "snapshots" of the values of the input, output, and error. It does
    not affect the rate at which the feedback is actually being done, which is controlled
    by the DT field in the EPID record, can be much faster than the SCAN value.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pid_control.adl</h3>
    <img alt="quadEM_pid_control.png" src="quadEM_pid_control.png" /></div>
  <p>
    This is the medm screen that controls the PID parameters. These include the feedback
    coefficients KP, KI, and KD. The DT (delta time) field controls the rate at which
    the feedback is actually been run. In this case DT=68.0 ms, which is 55 times longer
    than the sampling time (1.23 ms), so 55 position readings are being averaged each
    time the feedback is run.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pid_parameters.adl</h3>
    <img alt="quadEM_pid_parameters.png" src="quadEM_pid_parameters.png" /></div>
  <p>
    This is an medm screen that displays the setpoint of the pitch of the monochromator
    (in red), and the actual readback from the quadEM (in blue). Note that the readback
    here is only the snapshot values from the EPID record. For full-speed readings of
    the readback the waveform records from the quadEM_TimeSeries.template database would
    be used.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pid_plot_readback.adl</h3>
    <img alt="quadEM_plot_readback.png" src="quadEM_pid_plot_readback.png" /></div>
  <p>
    This is pid_fast.template, an example substitutions file. This example uses a quadEM
    asyn port driver named "APS_EM". ICHAN is set to read from addr=9 and 10, which
    are the two position values of the quadEM driver. The INPUT_DATA and INPUT_INTERVAL
    strings are the drvInfo strings for these parameters in the driver. The output is
    sent to an asyn port driver named DAC1, which is a dac128V 12-bit A/D converter
    in this data. OCHAN is set to write to addr=1 and 2, which are the second and third
    DAC channels on that card. The OUTPUT_DATA string is the drvInfo string for the
    double precision data in the dac128V.
  </p>
  <pre>
file "$(STD)/stdApp/Db/fast_pid_control.db"
{
pattern
{P,                 PID,  INPUT,     INPUT_DATA,   INPUT_INTERVAL, ICHAN, OUTPUT, OCHAN,  OUTPUT_DATA,    LOPR,     HOPR,  DRVL,  DRVH,  PREC,   KP,    KI,  KD,   DT,        SCAN}
{quadEMTest:, MonoPitch, APS_EM, QE_DOUBLE_DATA,   QE_SAMPLE_TIME,     9,   DAC1,     1,  DOUBLE_DATA,  -32767,    32767,     0,  4095,     3,  .02,  100.,  0., .001, ".1 second"}
{quadEMTest:,  MonoRoll, APS_EM, QE_DOUBLE_DATA,   QE_SAMPLE_TIME,    10,   DAC1,     2,  DOUBLE_DATA,  -32767,    32767,     0,  4095,     3,  .02,  100.,  0., .001, ".1 second"}
}
</pre>
  <h2 id="Performance">
    Performance</h2>
  <p>
    The following table shows the CPU utilization of a Linux machine (Xeon E5630 2.53GHz),
    vxWorks MVME2100, and vxWorks MVME5100 with the AH501 electometer as a function
    of the parameters that control the SampleTime. It can be seen that the load on Linux
    is very low. The load on the MVME5100 is significant, but it can handle NumChannels=4
    with NumAverage=1 for either resolution. The MVME2100 on the other hand cannot run
    with NumAverage=1 at all, it completely saturates the system. It does work NumAverage=4
    or 10.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: right">
    <tbody>
      <tr>
        <td align="center" colspan="5">
          <b>Performance of AH501 using UDP</b></td>
      </tr>
      <tr>
        <th>
          System</th>
        <th>
          NumChannels</th>
        <th>
          Resolution</th>
        <th>
          NumAverage</th>
        <th>
          %CPU time</th>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          1</td>
        <td>
          4%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          2</td>
        <td>
          2%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          2</td>
        <td>
          24</td>
        <td>
          1</td>
        <td>
          5%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          24</td>
        <td>
          1</td>
        <td>
          9%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          4</td>
        <td>
          16</td>
        <td>
          1</td>
        <td>
          4%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          2</td>
        <td>
          16</td>
        <td>
          1</td>
        <td>
          6%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          1</td>
        <td>
          16</td>
        <td>
          1</td>
        <td>
          7%</td>
      </tr>
      <tr>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          1</td>
        <td>
          37%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          2</td>
        <td>
          18%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          4</td>
        <td>
          9%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          2</td>
        <td>
          24</td>
        <td>
          1</td>
        <td>
          50%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          2</td>
        <td>
          24</td>
        <td>
          2</td>
        <td>
          24%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          4</td>
        <td>
          16</td>
        <td>
          1</td>
        <td>
          43%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          4</td>
        <td>
          16</td>
        <td>
          2</td>
        <td>
          20%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          2</td>
        <td>
          16</td>
        <td>
          1</td>
        <td>
          66%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          2</td>
        <td>
          16</td>
        <td>
          2</td>
        <td>
          36%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          16</td>
        <td>
          1</td>
        <td>
          91%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          16</td>
        <td>
          2</td>
        <td>
          48%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          1</td>
        <td>
          16</td>
        <td>
          4</td>
        <td>
          27%</td>
      </tr>
      <tr>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          2</td>
        <td>
          77%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          3</td>
        <td>
          52%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          4</td>
        <td>
          43%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          4</td>
        <td>
          24</td>
        <td>
          10</td>
        <td>
          19%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          4</td>
        <td>
          16</td>
        <td>
          4</td>
        <td>
          41%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          4</td>
        <td>
          16</td>
        <td>
          10</td>
        <td>
          15%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          1</td>
        <td>
          16</td>
        <td>
          10</td>
        <td>
          50%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          1</td>
        <td>
          16</td>
        <td>
          20</td>
        <td>
          29%</td>
      </tr>
    </tbody>
  </table>
  <p>
    The following table shows the CPU utilization of the Linux machine, vxWorks MVME2100,
    and vxWorks MVME5100 with the AH401B electometer as a function of the parameters
    that control the SampleTime. It can be seen that the load on Linux is almost unmeasurable.
    The load on the MVME5100 is small. The MVME2100 uses almost 50% of the CPU at the
    fastest sampling time, but increasing NumAverage or IntegrationTime reduces this
    to a small value.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: right">
    <tbody>
      <tr>
        <td align="center" colspan="5">
          <b>Performance of AH401B using TCP</b></td>
      </tr>
      <tr>
        <th>
          System</th>
        <th>
          IntegrationTime</th>
        <th>
          PingPong</th>
        <th>
          NumAverage</th>
        <th>
          %CPU time</th>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          0.001</td>
        <td>
          1</td>
        <td>
          1</td>
        <td>
          1%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          0.001</td>
        <td>
          1</td>
        <td>
          2</td>
        <td>
          &lt;1%</td>
      </tr>
      <tr>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          0.001</td>
        <td>
          1</td>
        <td>
          1</td>
        <td>
          12%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          0.001</td>
        <td>
          1</td>
        <td>
          2</td>
        <td>
          7%</td>
      </tr>
      <tr>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
        <td>
        </td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          0.001</td>
        <td>
          1</td>
        <td>
          1</td>
        <td>
          47%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          0.001</td>
        <td>
          1</td>
        <td>
          2</td>
        <td>
          27%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          0.001</td>
        <td>
          1</td>
        <td>
          4</td>
        <td>
          16%</td>
      </tr>
    </tbody>
  </table>
  <p>
    The following table shows the CPU utilization of vxWorks MVME2100, with the APS
    electometer as a function of the parameters that control the SampleTime. The MVME2100
    uses almost 50% of the CPU at the fastest sampling time, but increasing NumAverage
    or IntegrationTime reduces this to a small value. The MVME2700 and MVME5100 would
    show significantly lower CPU values, but measurements were not done with those systems
    with the test application.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: right">
    <tbody>
      <tr>
        <td align="center" colspan="4">
          <b>Performance of APS Electometer</b></td>
      </tr>
      <tr>
        <th>
          System</th>
        <th>
          IntegrationTime</th>
        <th>
          NumAverage</th>
        <th>
          %CPU time</th>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          0.0006</td>
        <td>
          1</td>
        <td>
          49%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          0.0006</td>
        <td>
          2</td>
        <td>
          35%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          0.001</td>
        <td>
          1</td>
        <td>
          40%</td>
      </tr>
      <tr>
        <td>
          MVME2100</td>
        <td>
          0.002</td>
        <td>
          1</td>
        <td>
          20%</td>
      </tr>
    </tbody>
  </table>
  <h2 id="AHxxx_Setup">
    AH401 and AH501 Series Setup</h2>
  <p>
    These meters communicates via IP, so they must be configured with an IP address
    reachable from the host IOC machine. The Lantronix module in the meters can be configured
    to use either UDP (recommended to reduce CPU load, particularly on AH501 series)
    or TCP. The startup script must include the UDP qualifier on the drvAsynIPPortConfigure
    command if UDP is selected.</p>
  <p>
    Example startup scripts for Linux or Windows are provided in
    <br />
    <a href="quadEM_st_cmd_AH401B.html">quadEM/iocBoot/iocTest.st.cmd.AH401B</a> and
    <br />
    <a href="quadEM_st_cmd_AH501.html">quadEM/iocBoot/iocTest.st.cmd.AH501</a>
  </p>
  <p>
    These will need to be edited to set the correct IP address of the meters to be used.</p>
  <p>
    These scripts each invoke a generic script:
    <br />
    <a href="quadEM_st_cmd_AHxxx.html">quadEM/iocBoot/iocTest.st.cmd.AHxxx</a>.
  </p>
  <h2 id="APS_EM_Setup">
    APS Electrometer Setup</h2>
  <p>
    The APS_EM VME card cannot generate interrupts, but it can output a TTL pulse each
    time new data is available, at up to 815 Hz. If this pulse is input to an Ip-Unidig
    (or other asyn digital I/O device with interrupt and callback capabilities), then
    the ipUnidig interrupt routine will call the APS_EM driver each time new data is
    available. The Ip-Unidig channel where the APS_EM pulse is connected is specified
    in the unidigChan argument to drvAPS_EMConfigure command in the startup script.
    If an Ip-Unidig or other interrupt source is not being used then the APS_EM driver
    will poll for new data at the system clock rate, typically 60Hz.</p>
  <p>
    An example startup script for vxWorks is provided in
    <br />
    <a href="quadEM_st_cmd_vxWorks.html">quadEM/iocBoot/iocTest.st.cmd.vxWorks</a>.
  </p>
  <p>
    This example startup script can be edited to start either the APS_EM, the AH401B,
    or the AH501. For the APS_EM this script invokes
    <br />
    <a href="quadEM_st_cmd_APS_EM.html">quadEM/iocBoot/iocTest.st.cmd.APS_EM</a>.
  </p>
</body>
</html>
